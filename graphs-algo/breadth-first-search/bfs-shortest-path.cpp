/*  SHORTEST PATH  ------------------------------------------------------------

    В данном файле на основе BFS решается классическая задача нахождения 
    кратчайшего пути между двумя вершинами в неориентированном
    невзвешенном графе.

---------------------------------------------------------------------------  */

#include <iostream>
#include <vector>
#include <queue>

using namespace std;


int main() {

    // `n` -- количество вершин, `m` -- количество рёбер
    int n, m;
    cin >> n >> m;

    /*
        ПРИМ. память под хранение информации о вершинах выделяется как `n + 1`
        с целью возможности обращения к вершинам по их имени (первые n 
        натуральных чисел)
    */ 

    // создаём вектор векторов для хранения списка смежности
    vector< vector< int > > graph(n + 1);
    // массив, в котором для каждой вершины будем хранить предка для каждой 
    // вершины (предка в порядке обхожа в ширину)
    vector< int > parent(n + 1, -1);

    // ввод информации о `m` рёбрах
    for (int i = 0; i < m; i++) {
        int first_vertex, second_vertex;
        cin >> first_vertex >> second_vertex;
        // устанавливаем связь ребра (`first_vertex`, `second_vertex`)
        graph[first_vertex].push_back(second_vertex);
        graph[second_vertex].push_back(first_vertex);
    }

    // ввод вершин, кратчайший путь между которыми нас интересует
    int start_vertex, finish_vertex;
    cin >> start_vertex >> finish_vertex;

    // создаём очередь для последующей реализации BFS
    queue< int > bfs_queue;
    bfs_queue.push(start_vertex);   // добавление в очередь первой вершины;
                                    // от данной вершины будет производиться 
                                    // поиск пути до всех остальных вершин
    parent[start_vertex] = start_vertex;    // для стартовой вершины будем 
                                            // считать предком саму эту вершину
                                            // (петля) 

    while (!bfs_queue.empty()) {

        // достаём из очереди очередную вершину
        int this_vertex = bfs_queue.front();
        bfs_queue.pop();

        // и рассматриваем её соседей
        for (int i = 0; i < graph[this_vertex].size(); i++) {
            // если у соседа ещё нет предка в порядке обхода
            if (parent[graph[this_vertex][i]] == -1) {
                // то добавляем её в очередь
                bfs_queue.push(graph[this_vertex][i]);
                // и назначаем предка
                parent[graph[this_vertex][i]] = this_vertex;
            }
        }
    }

    vector< int > path;     // массив для хранения пути (в обратном порядке)
    // создаём переменную, которая будет хранить очередное имя вершины в пути
    // начинаем перебирать от последней вершины, так как для каждой вершины
    // известен её однозначный предок в порядке обхода в ширину
    int temp_vertex = finish_vertex;
    // пока очередная вершина пути не является корнем дерева обхода 
    // (т.е вершина не является своим собественным предком)
    while (parent[temp_vertex] != temp_vertex) {
        // рассматриваем её как вершину пути
        path.push_back(temp_vertex);
        // и переходим к её предку
        temp_vertex = parent[temp_vertex];
    }
    path.push_back(temp_vertex);    // корень дерева так же добавляем


    // с учётом того, что при восстановлении пути мы шли от конечной вершины,
    // выводим путь в обратном порядке
    for (int i = path.size() - 1; i >= 0; i--) {
        cout << path[i] << ' ';
    }
    cout << '\n';
    
    return 0;
}