/*  BFS  ----------------------------------------------------------------------

    В данном файле описывается классический алгоритм проверки графа на 
    наличие цикла, постренный на основе обхода в глубину

---------------------------------------------------------------------------  */

#include <iostream>
#include <vector>

using namespace std;


// функция для проверки вершины `vertex` на состояние `быть предком циклу` --
// отношение `быть предком` к вершинам предполагаемого цикла
bool dfs(
        int vertex,                     // вершина, от которой запускается DFS
        vector< vector< int > >& graph, // ссылка на ориент. граф
        vector< int >& is_visited       // массив с пометками
) {
    is_visited[vertex] = 1;     // метим вершину `vertex` как вершину, от 
                                // которой был запущен DFS

    bool result = 0;    // предполагаем, что вершина `vertex` не является 
                        // вершиной-предком для вершин, образующих цикл
    
    // пробуем опровергнуть гипотезу (`result`)
    // проверяем всех соседей-вершин к вершине `vertex`
    for (int i = 0; i < graph[vertex].size(); i++) {
        // если вершина-сосед `graph[vertex][i]` не рассматривалась
        if (!is_visited[graph[vertex][i]]) {
            result += dfs(graph[vertex][i], graph, is_visited);
        }
        // если рассматривалась и DFS от неё не закончился
        else if (is_visited[graph[vertex][i]] == 1) {
            return 1;   // то нашли цикл
        }
    }

    // заканчиваем рассмотрение вершины, если не оборвали выполнение
    // функции в случае обнаружения цикла
    is_visited[vertex] = 2;

    // возвращаем `0`, если вершина `vertex` не является предком для вершин,
    // образующих цикл, иначе -- `1`
    return result;
}


// функция для проверки графа на наличие цикла, которая принимает в качестве
// аргумента ссылку на граф, а возращает булевой значение
bool is_cycle(vector< vector< int > >& graph) {
    // данная функция проверяет, наличие хотя бы одной вершины на отношение
    // `быть предком` для вершин, образующих цикл

    // создаём массив для меток вершин
    vector< int > is_visited(graph.size(), 0);

    // предполагаем вершин-предков для вершин, образующих цикл, нет
    bool result = 0;
    // пробуем опровергнуть
    for (int i = 1; i < graph.size(); i++) {
        // рассматрвиаем очередную вершину, если не рассматривали её ранее
        if (!is_visited[i]) {
            result += dfs(i, graph, is_visited);
        }
    }

    // возвращаем `1`, если был обнаружен цикл, иначе -- `0`
    return result;
}


int main() {
    
    int n, m;
    cin >> n >> m;

    vector< vector< int > > graph(n + 1);

    for (int i = 0; i < m; i++) {
        int first_vertex, second_vertex;
        cin >> first_vertex >> second_vertex;
        graph[first_vertex].push_back(second_vertex);
    }

    if (is_cycle(graph)) {
        cout << "YES" << endl;
    }
    else {
        cout << "NO" << endl;
    }

    return 0;
}