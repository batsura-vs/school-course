#include <iostream>

using namespace std;


struct Node {

    int value;      // значение записи
    Node* next;     // указатель на следующую запись

    /*  -----------------------------------------------------------------------
        Конструктор записи.
        Принимает в качестве аргумента значение для оборачивания,
        указатель на следующую запись является нулевыми
    -----------------------------------------------------------------------  */
    Node(int _value) {
        value = _value;
        next = nullptr;
    }

};


struct LinkedList {

    Node* front;    // указатель на начало списка
    Node* back;     // указатель на конец списка

    /*  -----------------------------------------------------------------------
        Конструктор односвязного списка.
        Указатели на начало и на конец списка -- нулевые указатели
    -----------------------------------------------------------------------  */
    LinkedList() {
        front = nullptr;
        back = nullptr;
    }

    /*  -----------------------------------------------------------------------
        Метод проверки на пустоту.
        Если указатель на начало -- нулевой указатель, 
        то связный список пустой
    -----------------------------------------------------------------------  */
    bool empty() {
        return front == nullptr;
    }

    /*  -----------------------------------------------------------------------
        Метод добавления нового элемента в конец списка
    -----------------------------------------------------------------------  */
    void push_back(int _value) {
        Node* new_elem = new Node(_value);
        if (this->empty()) {
            front = new_elem;
            back = new_elem;
        } else {
            back->next = new_elem;
            back = new_elem;
        }
    }

    /*  -----------------------------------------------------------------------
        Метод удаление элемента по значению
        (первого, который был встречен при обходе от начала)
    -----------------------------------------------------------------------  */
    void remove(int _value) {

        // если список пустой -- нечего удалять
        if (this->empty()) {
            return;
        }

        // если первый элемент имеет искомое значение -- удаляем его
        if (front->value == _value) {
            Node* old_elem = front;
            front = front->next;
            delete old_elem;
            return;
        }

        // иначе проходим с поиском по всему односвязному списку
        Node* current_elem = front;
        while (current_elem->next != nullptr) {
            if (current_elem->next->value == _value) {
                Node* old_elem = current_elem->next;
                current_elem->next = current_elem->next->next;
                delete old_elem;
                break;
            }
            current_elem = current_elem->next;
        }
    }

    /*  -----------------------------------------------------------------------
        Метод вывода значений списка
    -----------------------------------------------------------------------  */
    void print() {
        Node* current_elem = front;
        while (current_elem != nullptr) {
            cout << current_elem->value << ' ';
            current_elem = current_elem->next;
        }
        cout << '\n';
    }

};

int main() {

    int n;
    cin >> n;

    LinkedList ll = LinkedList();
    for (int i = 0; i < n; i++) {
        int tmp;
        cin >> tmp;
        ll.push_back(tmp);
    }

    return 0;
}
