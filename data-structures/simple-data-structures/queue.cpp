/*  ОЧЕРЕДЬ  ------------------------------------------------------------------

    В данном файле описывается классическая структура данных 
    -- Очередь (Queue).

    Приведённая реализация очереди подразумевается динамическое выделение 
    памяти (при добавлении элемента) и динамическое её освобождение при 
    необходимости (при удалении), по этой причине для описания стека 
    используются указатели.

---------------------------------------------------------------------------  */

#include <iostream>

using namespace std;


/*  ---------------------------------------------------------------------------
    Класс записи (Node) используется как обёртка
    для представления хранимых в очереди (Queue) данных
---------------------------------------------------------------------------  */
struct Node {
    
    int value;      // значение записи
    Node* prev;     // указатель на предыдущую запись

    /*  -----------------------------------------------------------------------
        Конструктор записи.
        Принимает в качестве аргумента значение для оборачивания,
        указатель на предыдущую запись является нулевым
    -----------------------------------------------------------------------  */
    Node(int _value) {
        value = _value;
        prev = nullptr;
    }

};


/*  ---------------------------------------------------------------------------
    Динамическая реализация класс очереди (Queue)
---------------------------------------------------------------------------  */
struct Queue {

    Node* front;    // указатель на начало очереди (первый элемент)
    Node* back;     // указатель на конец очереди (последний элемент)

    /*  -----------------------------------------------------------------------
        Конструктор очереди.
        Указатели на начало и на конец очереди -- нулевые указатели
        (очередь пуста)
    -----------------------------------------------------------------------  */
    Queue() {
        front = nullptr;
        back = nullptr;
    }

    /*  -----------------------------------------------------------------------
        Метод добавления нового значения в очередь.
        Значение оборачивается в запись 
        и добавляется в качестве конца очереди
    -----------------------------------------------------------------------  */
    void add(int _value) {
        Node* new_elem = new Node(_value);
        if (back == nullptr) {
            front = new_elem;
            back = new_elem;
        } else {
            back->prev = new_elem;
            back = new_elem;
        }
    }

    /*  -----------------------------------------------------------------------
        Метод извлечение элемента из очереди
    -----------------------------------------------------------------------  */
    int pop() {
        int result = front->value;
        Node* old_elem = front;
        front = front->prev;
        delete old_elem;
        return result;
    }

    /*  -----------------------------------------------------------------------
        Метод проверки на пустоту.
        Если указатель на начало -- нулевой указатель, то очередь пуста
    -----------------------------------------------------------------------  */
    bool empty() {
        return front == nullptr;
    }

};

int main() {

    Queue q = Queue();

    int n;
    cin >> n;

    for (int i = 0; i < n; i++) {
        int tmp;
        cin >> tmp;
        q.add(tmp);
    }

    while (!q.empty()) {
        cout << q.pop() << ' ';
    }
    cout << '\n';

    return 0;
}
